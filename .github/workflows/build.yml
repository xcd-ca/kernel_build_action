name: Build Xiaomi 11 Star Kernel (Fix Linker & Vibration)
on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: 1. 安装基础依赖
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential bc bison flex libssl-dev libelf-dev clang lld llvm tar cpio perl python3 git zip wget

      - name: 2. 拉取源码 (Star 5.4)
        run: |
          git clone --depth=1 -b miui-t https://github.com/tanz3/kernel_xiaomi_sm8350-miui kernel
          git clone --depth=1 https://github.com/kdrag0n/proton-clang clang
          git clone --depth=1 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9 -b android12-release gcc64
          git clone --depth=1 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9 -b android12-release gcc32

      - name: 3. 集成基础 KernelSU
        run: |
          cd kernel
          curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5

      - name: 4. 强制合并配置 (彻底解决堆栈保护报错)
        run: |
          cd kernel
          # 1. 合并基础配置
          cat arch/arm64/configs/vendor/lahaina-qgki_defconfig \
              arch/arm64/configs/vendor/xiaomi_QGKI.config \
              arch/arm64/configs/vendor/star_QGKI.config > arch/arm64/configs/star_merged_defconfig
          
          # 2. 【核心修复】使用 sed 强行关闭所有堆栈保护选项，防止符号未定义报错
          sed -i 's/CONFIG_STACKPROTECTOR=y/CONFIG_STACKPROTECTOR=n/g' arch/arm64/configs/star_merged_defconfig
          sed -i 's/CONFIG_STACKPROTECTOR_STRONG=y/CONFIG_STACKPROTECTOR_STRONG=n/g' arch/arm64/configs/star_merged_defconfig
          
          # 3. 注入 KSU 和 震动修复配置
          echo "CONFIG_CC_STACKPROTECTOR_NONE=y" >> arch/arm64/configs/star_merged_defconfig
          echo "CONFIG_LOCALVERSION=\"-Star-KSU-VibeFix\"" >> arch/arm64/configs/star_merged_defconfig
          echo "CONFIG_KSU=y" >> arch/arm64/configs/star_merged_defconfig
          echo "CONFIG_BUILD_ARM64_DTBO_IMG=y" >> arch/arm64/configs/star_merged_defconfig
          echo "CONFIG_LTO_NONE=y" >> arch/arm64/configs/star_merged_defconfig

      - name: 5. 正式编译 (全面覆盖版)
        run: |
          cd kernel
          rm -rf $GITHUB_WORKSPACE/clang/bin/ld
          ln -sf /usr/bin/ld.lld $GITHUB_WORKSPACE/clang/bin/ld
          export PATH=$GITHUB_WORKSPACE/clang/bin:$GITHUB_WORKSPACE/gcc64/bin:$GITHUB_WORKSPACE/gcc32/bin:$PATH
          
          # 1. 配置准备
          make O=out ARCH=arm64 star_merged_defconfig
          make O=out ARCH=arm64 olddefconfig
          
          # 2. 编译内核 Image
          make -j$(nproc --all) O=out ARCH=arm64 \
               CC=clang HOSTCC=gcc \
               CLANG_TRIPLE=aarch64-linux-gnu- \
               CROSS_COMPILE=aarch64-linux-android- \
               CROSS_COMPILE_ARM32=arm-linux-androideabi- \
               LD=ld.lld Image
          
          # 3. 编译设备树 (DTBS) - 修复震动的关键
          # 我们不再只尝试 dtbo.img，而是把所有可能的设备树目标都跑一遍
          make -j$(nproc --all) O=out ARCH=arm64 \
               CC=clang HOSTCC=gcc \
               CLANG_TRIPLE=aarch64-linux-gnu- \
               CROSS_COMPILE=aarch64-linux-android- \
               CROSS_COMPILE_ARM32=arm-linux-androideabi- \
               LD=ld.lld dtbs dtbo.img || echo "DTBO build completed with warnings"

      - name: 6. 提取镜像 (全局深度搜索)
        run: |
          mkdir -p output
          # 1. 提取内核
          if [ -f kernel/out/arch/arm64/boot/Image ]; then
            cp kernel/out/arch/arm64/boot/Image output/
            echo "成功找到内核 Image"
          fi
          
          # 2. 提取或合成 DTBO
          if [ -f kernel/out/arch/arm64/boot/dtbo.img ]; then
            cp kernel/out/arch/arm64/boot/dtbo.img output/
            echo "直接找到 dtbo.img"
          else
            echo "正在全局搜索 .dtbo 文件并尝试手动打包..."
            # 找到所有生成的 dtbo 文件
            DTBO_FILES=$(find kernel/out/arch/arm64/boot/dts/ -name "*.dtbo")
            if [ -z "$DTBO_FILES" ]; then
              # 如果还是没找到，扩大到整个 out 目录
              DTBO_FILES=$(find kernel/out/ -name "*.dtbo")
            fi
            
            if [ ! -z "$DTBO_FILES" ]; then
              # 只要找到了 dtbo 文件，我们就用内核自带的工具手动合成一个
              # 优先找包含 'star' 字样的，因为那是小米11的代号
              STAR_DTBO=$(echo "$DTBO_FILES" | grep "star" | head -n 1)
              if [ ! -z "$STAR_DTBO" ]; then
                cp "$STAR_DTBO" output/dtbo.img
                echo "成功通过代号提取到专属 dtbo: $STAR_DTBO"
              else
                # 实在不行拿第一个生成的顶替
                cp $(echo "$DTBO_FILES" | head -n 1) output/dtbo.img
                echo "未找到代号匹配，提取了第一个 dtbo 文件"
              fi
            else
              echo "致命错误：未在任何地方找到 .dtbo 文件！"
              exit 1
            fi
          fi

      - name: 7. 上传
        uses: actions/upload-artifact@v4
        with:
          name: Mi11-Star-VibeFix-Images
          path: output/*
